// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: peer/proposal_response.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Chaincode.NET.Protos {

  /// <summary>Holder for reflection information generated from peer/proposal_response.proto</summary>
  public static partial class ProposalResponseReflection {

    #region Descriptor
    /// <summary>File descriptor for peer/proposal_response.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ProposalResponseReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChxwZWVyL3Byb3Bvc2FsX3Jlc3BvbnNlLnByb3RvEgZwcm90b3MaH2dvb2ds",
            "ZS9wcm90b2J1Zi90aW1lc3RhbXAucHJvdG8isQEKEFByb3Bvc2FsUmVzcG9u",
            "c2USDwoHdmVyc2lvbhgBIAEoBRItCgl0aW1lc3RhbXAYAiABKAsyGi5nb29n",
            "bGUucHJvdG9idWYuVGltZXN0YW1wEiIKCHJlc3BvbnNlGAQgASgLMhAucHJv",
            "dG9zLlJlc3BvbnNlEg8KB3BheWxvYWQYBSABKAwSKAoLZW5kb3JzZW1lbnQY",
            "BiABKAsyEy5wcm90b3MuRW5kb3JzZW1lbnQiPAoIUmVzcG9uc2USDgoGc3Rh",
            "dHVzGAEgASgFEg8KB21lc3NhZ2UYAiABKAkSDwoHcGF5bG9hZBgDIAEoDCJD",
            "ChdQcm9wb3NhbFJlc3BvbnNlUGF5bG9hZBIVCg1wcm9wb3NhbF9oYXNoGAEg",
            "ASgMEhEKCWV4dGVuc2lvbhgCIAEoDCIyCgtFbmRvcnNlbWVudBIQCghlbmRv",
            "cnNlchgBIAEoDBIRCglzaWduYXR1cmUYAiABKAxCfwoib3JnLmh5cGVybGVk",
            "Z2VyLmZhYnJpYy5wcm90b3MucGVlckIXUHJvcG9zYWxSZXNwb25zZVBhY2th",
            "Z2VaKWdpdGh1Yi5jb20vaHlwZXJsZWRnZXIvZmFicmljL3Byb3Rvcy9wZWVy",
            "qgIUQ2hhaW5jb2RlLk5FVC5Qcm90b3NiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Chaincode.NET.Protos.ProposalResponse), global::Chaincode.NET.Protos.ProposalResponse.Parser, new[]{ "Version", "Timestamp", "Response", "Payload", "Endorsement" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Chaincode.NET.Protos.Response), global::Chaincode.NET.Protos.Response.Parser, new[]{ "Status", "Message", "Payload" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Chaincode.NET.Protos.ProposalResponsePayload), global::Chaincode.NET.Protos.ProposalResponsePayload.Parser, new[]{ "ProposalHash", "Extension" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Chaincode.NET.Protos.Endorsement), global::Chaincode.NET.Protos.Endorsement.Parser, new[]{ "Endorser", "Signature" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// A ProposalResponse is returned from an endorser to the proposal submitter.
  /// The idea is that this message contains the endorser's response to the
  /// request of a client to perform an action over a chaincode (or more
  /// generically on the ledger); the response might be success/error (conveyed in
  /// the Response field) together with a description of the action and a
  /// signature over it by that endorser.  If a sufficient number of distinct
  /// endorsers agree on the same action and produce signature to that effect, a
  /// transaction can be generated and sent for ordering.
  /// </summary>
  public sealed partial class ProposalResponse : pb::IMessage<ProposalResponse> {
    private static readonly pb::MessageParser<ProposalResponse> _parser = new pb::MessageParser<ProposalResponse>(() => new ProposalResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ProposalResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Chaincode.NET.Protos.ProposalResponseReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProposalResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProposalResponse(ProposalResponse other) : this() {
      version_ = other.version_;
      timestamp_ = other.timestamp_ != null ? other.timestamp_.Clone() : null;
      response_ = other.response_ != null ? other.response_.Clone() : null;
      payload_ = other.payload_;
      endorsement_ = other.endorsement_ != null ? other.endorsement_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProposalResponse Clone() {
      return new ProposalResponse(this);
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 1;
    private int version_;
    /// <summary>
    /// Version indicates message protocol version
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Version {
      get { return version_; }
      set {
        version_ = value;
      }
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp timestamp_;
    /// <summary>
    /// Timestamp is the time that the message
    /// was created as  defined by the sender
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    /// <summary>Field number for the "response" field.</summary>
    public const int ResponseFieldNumber = 4;
    private global::Chaincode.NET.Protos.Response response_;
    /// <summary>
    /// A response message indicating whether the
    /// endorsement of the action was successful
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Chaincode.NET.Protos.Response Response {
      get { return response_; }
      set {
        response_ = value;
      }
    }

    /// <summary>Field number for the "payload" field.</summary>
    public const int PayloadFieldNumber = 5;
    private pb::ByteString payload_ = pb::ByteString.Empty;
    /// <summary>
    /// The payload of response. It is the bytes of ProposalResponsePayload
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Payload {
      get { return payload_; }
      set {
        payload_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "endorsement" field.</summary>
    public const int EndorsementFieldNumber = 6;
    private global::Chaincode.NET.Protos.Endorsement endorsement_;
    /// <summary>
    /// The endorsement of the proposal, basically
    /// the endorser's signature over the payload
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Chaincode.NET.Protos.Endorsement Endorsement {
      get { return endorsement_; }
      set {
        endorsement_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ProposalResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ProposalResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Version != other.Version) return false;
      if (!object.Equals(Timestamp, other.Timestamp)) return false;
      if (!object.Equals(Response, other.Response)) return false;
      if (Payload != other.Payload) return false;
      if (!object.Equals(Endorsement, other.Endorsement)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Version != 0) hash ^= Version.GetHashCode();
      if (timestamp_ != null) hash ^= Timestamp.GetHashCode();
      if (response_ != null) hash ^= Response.GetHashCode();
      if (Payload.Length != 0) hash ^= Payload.GetHashCode();
      if (endorsement_ != null) hash ^= Endorsement.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Version != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Version);
      }
      if (timestamp_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Timestamp);
      }
      if (response_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Response);
      }
      if (Payload.Length != 0) {
        output.WriteRawTag(42);
        output.WriteBytes(Payload);
      }
      if (endorsement_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Endorsement);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Version != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Version);
      }
      if (timestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timestamp);
      }
      if (response_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Response);
      }
      if (Payload.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Payload);
      }
      if (endorsement_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Endorsement);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ProposalResponse other) {
      if (other == null) {
        return;
      }
      if (other.Version != 0) {
        Version = other.Version;
      }
      if (other.timestamp_ != null) {
        if (timestamp_ == null) {
          Timestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        Timestamp.MergeFrom(other.Timestamp);
      }
      if (other.response_ != null) {
        if (response_ == null) {
          Response = new global::Chaincode.NET.Protos.Response();
        }
        Response.MergeFrom(other.Response);
      }
      if (other.Payload.Length != 0) {
        Payload = other.Payload;
      }
      if (other.endorsement_ != null) {
        if (endorsement_ == null) {
          Endorsement = new global::Chaincode.NET.Protos.Endorsement();
        }
        Endorsement.MergeFrom(other.Endorsement);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Version = input.ReadInt32();
            break;
          }
          case 18: {
            if (timestamp_ == null) {
              Timestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Timestamp);
            break;
          }
          case 34: {
            if (response_ == null) {
              Response = new global::Chaincode.NET.Protos.Response();
            }
            input.ReadMessage(Response);
            break;
          }
          case 42: {
            Payload = input.ReadBytes();
            break;
          }
          case 50: {
            if (endorsement_ == null) {
              Endorsement = new global::Chaincode.NET.Protos.Endorsement();
            }
            input.ReadMessage(Endorsement);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A response with a representation similar to an HTTP response that can
  /// be used within another message.
  /// </summary>
  public sealed partial class Response : pb::IMessage<Response> {
    private static readonly pb::MessageParser<Response> _parser = new pb::MessageParser<Response>(() => new Response());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Response> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Chaincode.NET.Protos.ProposalResponseReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Response() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Response(Response other) : this() {
      status_ = other.status_;
      message_ = other.message_;
      payload_ = other.payload_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Response Clone() {
      return new Response(this);
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 1;
    private int status_;
    /// <summary>
    /// A status code that should follow the HTTP status codes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 2;
    private string message_ = "";
    /// <summary>
    /// A message associated with the response code.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Message {
      get { return message_; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "payload" field.</summary>
    public const int PayloadFieldNumber = 3;
    private pb::ByteString payload_ = pb::ByteString.Empty;
    /// <summary>
    /// A payload that can be used to include metadata with this response.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Payload {
      get { return payload_; }
      set {
        payload_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Response);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Response other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Status != other.Status) return false;
      if (Message != other.Message) return false;
      if (Payload != other.Payload) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Status != 0) hash ^= Status.GetHashCode();
      if (Message.Length != 0) hash ^= Message.GetHashCode();
      if (Payload.Length != 0) hash ^= Payload.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Status != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Status);
      }
      if (Message.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Message);
      }
      if (Payload.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(Payload);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Status != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Status);
      }
      if (Message.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (Payload.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Payload);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Response other) {
      if (other == null) {
        return;
      }
      if (other.Status != 0) {
        Status = other.Status;
      }
      if (other.Message.Length != 0) {
        Message = other.Message;
      }
      if (other.Payload.Length != 0) {
        Payload = other.Payload;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Status = input.ReadInt32();
            break;
          }
          case 18: {
            Message = input.ReadString();
            break;
          }
          case 26: {
            Payload = input.ReadBytes();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// ProposalResponsePayload is the payload of a proposal response.  This message
  /// is the "bridge" between the client's request and the endorser's action in
  /// response to that request. Concretely, for chaincodes, it contains a hashed
  /// representation of the proposal (proposalHash) and a representation of the
  /// chaincode state changes and events inside the extension field.
  /// </summary>
  public sealed partial class ProposalResponsePayload : pb::IMessage<ProposalResponsePayload> {
    private static readonly pb::MessageParser<ProposalResponsePayload> _parser = new pb::MessageParser<ProposalResponsePayload>(() => new ProposalResponsePayload());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ProposalResponsePayload> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Chaincode.NET.Protos.ProposalResponseReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProposalResponsePayload() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProposalResponsePayload(ProposalResponsePayload other) : this() {
      proposalHash_ = other.proposalHash_;
      extension_ = other.extension_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProposalResponsePayload Clone() {
      return new ProposalResponsePayload(this);
    }

    /// <summary>Field number for the "proposal_hash" field.</summary>
    public const int ProposalHashFieldNumber = 1;
    private pb::ByteString proposalHash_ = pb::ByteString.Empty;
    /// <summary>
    /// Hash of the proposal that triggered this response. The hash is used to
    /// link a response with its proposal, both for bookeeping purposes on an
    /// asynchronous system and for security reasons (accountability,
    /// non-repudiation). The hash usually covers the entire Proposal message
    /// (byte-by-byte). However this implies that the hash can only be verified
    /// if the entire proposal message is available when ProposalResponsePayload is
    /// included in a transaction or stored in the ledger. For confidentiality
    /// reasons, with chaincodes it might be undesirable to store the proposal
    /// payload in the ledger.  If the type is CHAINCODE, this is handled by
    /// separating the proposal's header and
    /// the payload: the header is always hashed in its entirety whereas the
    /// payload can either be hashed fully, or only its hash may be hashed, or
    /// nothing from the payload can be hashed. The PayloadVisibility field in the
    /// Header's extension controls to which extent the proposal payload is
    /// "visible" in the sense that was just explained.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString ProposalHash {
      get { return proposalHash_; }
      set {
        proposalHash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "extension" field.</summary>
    public const int ExtensionFieldNumber = 2;
    private pb::ByteString extension_ = pb::ByteString.Empty;
    /// <summary>
    /// Extension should be unmarshaled to a type-specific message. The type of
    /// the extension in any proposal response depends on the type of the proposal
    /// that the client selected when the proposal was initially sent out.  In
    /// particular, this information is stored in the type field of a Header.  For
    /// chaincode, it's a ChaincodeAction message
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Extension {
      get { return extension_; }
      set {
        extension_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ProposalResponsePayload);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ProposalResponsePayload other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ProposalHash != other.ProposalHash) return false;
      if (Extension != other.Extension) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ProposalHash.Length != 0) hash ^= ProposalHash.GetHashCode();
      if (Extension.Length != 0) hash ^= Extension.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ProposalHash.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(ProposalHash);
      }
      if (Extension.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(Extension);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ProposalHash.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ProposalHash);
      }
      if (Extension.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Extension);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ProposalResponsePayload other) {
      if (other == null) {
        return;
      }
      if (other.ProposalHash.Length != 0) {
        ProposalHash = other.ProposalHash;
      }
      if (other.Extension.Length != 0) {
        Extension = other.Extension;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ProposalHash = input.ReadBytes();
            break;
          }
          case 18: {
            Extension = input.ReadBytes();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// An endorsement is a signature of an endorser over a proposal response.  By
  /// producing an endorsement message, an endorser implicitly "approves" that
  /// proposal response and the actions contained therein. When enough
  /// endorsements have been collected, a transaction can be generated out of a
  /// set of proposal responses.  Note that this message only contains an identity
  /// and a signature but no signed payload. This is intentional because
  /// endorsements are supposed to be collected in a transaction, and they are all
  /// expected to endorse a single proposal response/action (many endorsements
  /// over a single proposal response)
  /// </summary>
  public sealed partial class Endorsement : pb::IMessage<Endorsement> {
    private static readonly pb::MessageParser<Endorsement> _parser = new pb::MessageParser<Endorsement>(() => new Endorsement());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Endorsement> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Chaincode.NET.Protos.ProposalResponseReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Endorsement() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Endorsement(Endorsement other) : this() {
      endorser_ = other.endorser_;
      signature_ = other.signature_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Endorsement Clone() {
      return new Endorsement(this);
    }

    /// <summary>Field number for the "endorser" field.</summary>
    public const int EndorserFieldNumber = 1;
    private pb::ByteString endorser_ = pb::ByteString.Empty;
    /// <summary>
    /// Identity of the endorser (e.g. its certificate)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Endorser {
      get { return endorser_; }
      set {
        endorser_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "signature" field.</summary>
    public const int SignatureFieldNumber = 2;
    private pb::ByteString signature_ = pb::ByteString.Empty;
    /// <summary>
    /// Signature of the payload included in ProposalResponse concatenated with
    /// the endorser's certificate; ie, sign(ProposalResponse.payload + endorser)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Signature {
      get { return signature_; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Endorsement);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Endorsement other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Endorser != other.Endorser) return false;
      if (Signature != other.Signature) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Endorser.Length != 0) hash ^= Endorser.GetHashCode();
      if (Signature.Length != 0) hash ^= Signature.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Endorser.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Endorser);
      }
      if (Signature.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(Signature);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Endorser.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Endorser);
      }
      if (Signature.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Signature);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Endorsement other) {
      if (other == null) {
        return;
      }
      if (other.Endorser.Length != 0) {
        Endorser = other.Endorser;
      }
      if (other.Signature.Length != 0) {
        Signature = other.Signature;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Endorser = input.ReadBytes();
            break;
          }
          case 18: {
            Signature = input.ReadBytes();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
