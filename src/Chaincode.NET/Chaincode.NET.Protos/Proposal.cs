// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: peer/proposal.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Protos {

  /// <summary>Holder for reflection information generated from peer/proposal.proto</summary>
  public static partial class ProposalReflection {

    #region Descriptor
    /// <summary>File descriptor for peer/proposal.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ProposalReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChNwZWVyL3Byb3Bvc2FsLnByb3RvEgZwcm90b3MaFHBlZXIvY2hhaW5jb2Rl",
            "LnByb3RvGhxwZWVyL3Byb3Bvc2FsX3Jlc3BvbnNlLnByb3RvIjsKDlNpZ25l",
            "ZFByb3Bvc2FsEhYKDnByb3Bvc2FsX2J5dGVzGAEgASgMEhEKCXNpZ25hdHVy",
            "ZRgCIAEoDCI+CghQcm9wb3NhbBIOCgZoZWFkZXIYASABKAwSDwoHcGF5bG9h",
            "ZBgCIAEoDBIRCglleHRlbnNpb24YAyABKAwiYQoYQ2hhaW5jb2RlSGVhZGVy",
            "RXh0ZW5zaW9uEhoKEnBheWxvYWRfdmlzaWJpbGl0eRgBIAEoDBIpCgxjaGFp",
            "bmNvZGVfaWQYAiABKAsyEy5wcm90b3MuQ2hhaW5jb2RlSUQiqAEKGENoYWlu",
            "Y29kZVByb3Bvc2FsUGF5bG9hZBINCgVpbnB1dBgBIAEoDBJICgxUcmFuc2ll",
            "bnRNYXAYAiADKAsyMi5wcm90b3MuQ2hhaW5jb2RlUHJvcG9zYWxQYXlsb2Fk",
            "LlRyYW5zaWVudE1hcEVudHJ5GjMKEVRyYW5zaWVudE1hcEVudHJ5EgsKA2tl",
            "eRgBIAEoCRINCgV2YWx1ZRgCIAEoDDoCOAEigQEKD0NoYWluY29kZUFjdGlv",
            "bhIPCgdyZXN1bHRzGAEgASgMEg4KBmV2ZW50cxgCIAEoDBIiCghyZXNwb25z",
            "ZRgDIAEoCzIQLnByb3Rvcy5SZXNwb25zZRIpCgxjaGFpbmNvZGVfaWQYBCAB",
            "KAsyEy5wcm90b3MuQ2hhaW5jb2RlSURCYAoib3JnLmh5cGVybGVkZ2VyLmZh",
            "YnJpYy5wcm90b3MucGVlckIPUHJvcG9zYWxQYWNrYWdlWilnaXRodWIuY29t",
            "L2h5cGVybGVkZ2VyL2ZhYnJpYy9wcm90b3MvcGVlcmIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Protos.ChaincodeReflection.Descriptor, global::Protos.ProposalResponseReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Protos.SignedProposal), global::Protos.SignedProposal.Parser, new[]{ "ProposalBytes", "Signature" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protos.Proposal), global::Protos.Proposal.Parser, new[]{ "Header", "Payload", "Extension" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protos.ChaincodeHeaderExtension), global::Protos.ChaincodeHeaderExtension.Parser, new[]{ "PayloadVisibility", "ChaincodeId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protos.ChaincodeProposalPayload), global::Protos.ChaincodeProposalPayload.Parser, new[]{ "Input", "TransientMap" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protos.ChaincodeAction), global::Protos.ChaincodeAction.Parser, new[]{ "Results", "Events", "Response", "ChaincodeId" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// This structure is necessary to sign the proposal which contains the header
  /// and the payload. Without this structure, we would have to concatenate the
  /// header and the payload to verify the signature, which could be expensive
  /// with large payload
  ///
  /// When an endorser receives a SignedProposal message, it should verify the
  /// signature over the proposal bytes. This verification requires the following
  /// steps:
  /// 1. Verification of the validity of the certificate that was used to produce
  ///    the signature.  The certificate will be available once proposalBytes has
  ///    been unmarshalled to a Proposal message, and Proposal.header has been
  ///    unmarshalled to a Header message. While this unmarshalling-before-verifying
  ///    might not be ideal, it is unavoidable because i) the signature needs to also
  ///    protect the signing certificate; ii) it is desirable that Header is created
  ///    once by the client and never changed (for the sake of accountability and
  ///    non-repudiation). Note also that it is actually impossible to conclusively
  ///    verify the validity of the certificate included in a Proposal, because the
  ///    proposal needs to first be endorsed and ordered with respect to certificate
  ///    expiration transactions. Still, it is useful to pre-filter expired
  ///    certificates at this stage.
  /// 2. Verification that the certificate is trusted (signed by a trusted CA) and
  ///    that it is allowed to transact with us (with respect to some ACLs);
  /// 3. Verification that the signature on proposalBytes is valid;
  /// 4. Detect replay attacks;
  /// </summary>
  public sealed partial class SignedProposal : pb::IMessage<SignedProposal> {
    private static readonly pb::MessageParser<SignedProposal> _parser = new pb::MessageParser<SignedProposal>(() => new SignedProposal());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SignedProposal> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protos.ProposalReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignedProposal() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignedProposal(SignedProposal other) : this() {
      proposalBytes_ = other.proposalBytes_;
      signature_ = other.signature_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignedProposal Clone() {
      return new SignedProposal(this);
    }

    /// <summary>Field number for the "proposal_bytes" field.</summary>
    public const int ProposalBytesFieldNumber = 1;
    private pb::ByteString proposalBytes_ = pb::ByteString.Empty;
    /// <summary>
    /// The bytes of Proposal
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString ProposalBytes {
      get { return proposalBytes_; }
      set {
        proposalBytes_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "signature" field.</summary>
    public const int SignatureFieldNumber = 2;
    private pb::ByteString signature_ = pb::ByteString.Empty;
    /// <summary>
    /// Signaure over proposalBytes; this signature is to be verified against
    /// the creator identity contained in the header of the Proposal message
    /// marshaled as proposalBytes
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Signature {
      get { return signature_; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SignedProposal);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SignedProposal other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ProposalBytes != other.ProposalBytes) return false;
      if (Signature != other.Signature) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ProposalBytes.Length != 0) hash ^= ProposalBytes.GetHashCode();
      if (Signature.Length != 0) hash ^= Signature.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ProposalBytes.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(ProposalBytes);
      }
      if (Signature.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(Signature);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ProposalBytes.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ProposalBytes);
      }
      if (Signature.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Signature);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SignedProposal other) {
      if (other == null) {
        return;
      }
      if (other.ProposalBytes.Length != 0) {
        ProposalBytes = other.ProposalBytes;
      }
      if (other.Signature.Length != 0) {
        Signature = other.Signature;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ProposalBytes = input.ReadBytes();
            break;
          }
          case 18: {
            Signature = input.ReadBytes();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A Proposal is sent to an endorser for endorsement.  The proposal contains:
  /// 1. A header which should be unmarshaled to a Header message.  Note that
  ///    Header is both the header of a Proposal and of a Transaction, in that i)
  ///    both headers should be unmarshaled to this message; and ii) it is used to
  ///    compute cryptographic hashes and signatures.  The header has fields common
  ///    to all proposals/transactions.  In addition it has a type field for
  ///    additional customization. An example of this is the ChaincodeHeaderExtension
  ///    message used to extend the Header for type CHAINCODE.
  /// 2. A payload whose type depends on the header's type field.
  /// 3. An extension whose type depends on the header's type field.
  ///
  /// Let us see an example. For type CHAINCODE (see the Header message),
  /// we have the following:
  /// 1. The header is a Header message whose extensions field is a
  ///    ChaincodeHeaderExtension message.
  /// 2. The payload is a ChaincodeProposalPayload message.
  /// 3. The extension is a ChaincodeAction that might be used to ask the
  ///    endorsers to endorse a specific ChaincodeAction, thus emulating the
  ///    submitting peer model.
  /// </summary>
  public sealed partial class Proposal : pb::IMessage<Proposal> {
    private static readonly pb::MessageParser<Proposal> _parser = new pb::MessageParser<Proposal>(() => new Proposal());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Proposal> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protos.ProposalReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Proposal() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Proposal(Proposal other) : this() {
      header_ = other.header_;
      payload_ = other.payload_;
      extension_ = other.extension_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Proposal Clone() {
      return new Proposal(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private pb::ByteString header_ = pb::ByteString.Empty;
    /// <summary>
    /// The header of the proposal. It is the bytes of the Header
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Header {
      get { return header_; }
      set {
        header_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "payload" field.</summary>
    public const int PayloadFieldNumber = 2;
    private pb::ByteString payload_ = pb::ByteString.Empty;
    /// <summary>
    /// The payload of the proposal as defined by the type in the proposal
    /// header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Payload {
      get { return payload_; }
      set {
        payload_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "extension" field.</summary>
    public const int ExtensionFieldNumber = 3;
    private pb::ByteString extension_ = pb::ByteString.Empty;
    /// <summary>
    /// Optional extensions to the proposal. Its content depends on the Header's
    /// type field.  For the type CHAINCODE, it might be the bytes of a
    /// ChaincodeAction message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Extension {
      get { return extension_; }
      set {
        extension_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Proposal);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Proposal other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Header != other.Header) return false;
      if (Payload != other.Payload) return false;
      if (Extension != other.Extension) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Header.Length != 0) hash ^= Header.GetHashCode();
      if (Payload.Length != 0) hash ^= Payload.GetHashCode();
      if (Extension.Length != 0) hash ^= Extension.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Header.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Header);
      }
      if (Payload.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(Payload);
      }
      if (Extension.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(Extension);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Header.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Header);
      }
      if (Payload.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Payload);
      }
      if (Extension.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Extension);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Proposal other) {
      if (other == null) {
        return;
      }
      if (other.Header.Length != 0) {
        Header = other.Header;
      }
      if (other.Payload.Length != 0) {
        Payload = other.Payload;
      }
      if (other.Extension.Length != 0) {
        Extension = other.Extension;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Header = input.ReadBytes();
            break;
          }
          case 18: {
            Payload = input.ReadBytes();
            break;
          }
          case 26: {
            Extension = input.ReadBytes();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// ChaincodeHeaderExtension is the Header's extentions message to be used when
  /// the Header's type is CHAINCODE.  This extensions is used to specify which
  /// chaincode to invoke and what should appear on the ledger.
  /// </summary>
  public sealed partial class ChaincodeHeaderExtension : pb::IMessage<ChaincodeHeaderExtension> {
    private static readonly pb::MessageParser<ChaincodeHeaderExtension> _parser = new pb::MessageParser<ChaincodeHeaderExtension>(() => new ChaincodeHeaderExtension());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ChaincodeHeaderExtension> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protos.ProposalReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ChaincodeHeaderExtension() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ChaincodeHeaderExtension(ChaincodeHeaderExtension other) : this() {
      payloadVisibility_ = other.payloadVisibility_;
      ChaincodeId = other.chaincodeId_ != null ? other.ChaincodeId.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ChaincodeHeaderExtension Clone() {
      return new ChaincodeHeaderExtension(this);
    }

    /// <summary>Field number for the "payload_visibility" field.</summary>
    public const int PayloadVisibilityFieldNumber = 1;
    private pb::ByteString payloadVisibility_ = pb::ByteString.Empty;
    /// <summary>
    /// The PayloadVisibility field controls to what extent the Proposal's payload
    /// (recall that for the type CHAINCODE, it is ChaincodeProposalPayload
    /// message) field will be visible in the final transaction and in the ledger.
    /// Ideally, it would be configurable, supporting at least 3 main visibility
    /// modes:
    /// 1. all bytes of the payload are visible;
    /// 2. only a hash of the payload is visible;
    /// 3. nothing is visible.
    /// Notice that the visibility function may be potentially part of the ESCC.
    /// In that case it overrides PayloadVisibility field.  Finally notice that
    /// this field impacts the content of ProposalResponsePayload.proposalHash.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString PayloadVisibility {
      get { return payloadVisibility_; }
      set {
        payloadVisibility_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "chaincode_id" field.</summary>
    public const int ChaincodeIdFieldNumber = 2;
    private global::Protos.ChaincodeID chaincodeId_;
    /// <summary>
    /// The ID of the chaincode to target.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protos.ChaincodeID ChaincodeId {
      get { return chaincodeId_; }
      set {
        chaincodeId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ChaincodeHeaderExtension);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ChaincodeHeaderExtension other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PayloadVisibility != other.PayloadVisibility) return false;
      if (!object.Equals(ChaincodeId, other.ChaincodeId)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (PayloadVisibility.Length != 0) hash ^= PayloadVisibility.GetHashCode();
      if (chaincodeId_ != null) hash ^= ChaincodeId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (PayloadVisibility.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PayloadVisibility);
      }
      if (chaincodeId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ChaincodeId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (PayloadVisibility.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PayloadVisibility);
      }
      if (chaincodeId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ChaincodeId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ChaincodeHeaderExtension other) {
      if (other == null) {
        return;
      }
      if (other.PayloadVisibility.Length != 0) {
        PayloadVisibility = other.PayloadVisibility;
      }
      if (other.chaincodeId_ != null) {
        if (chaincodeId_ == null) {
          chaincodeId_ = new global::Protos.ChaincodeID();
        }
        ChaincodeId.MergeFrom(other.ChaincodeId);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PayloadVisibility = input.ReadBytes();
            break;
          }
          case 18: {
            if (chaincodeId_ == null) {
              chaincodeId_ = new global::Protos.ChaincodeID();
            }
            input.ReadMessage(chaincodeId_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// ChaincodeProposalPayload is the Proposal's payload message to be used when
  /// the Header's type is CHAINCODE.  It contains the arguments for this
  /// invocation.
  /// </summary>
  public sealed partial class ChaincodeProposalPayload : pb::IMessage<ChaincodeProposalPayload> {
    private static readonly pb::MessageParser<ChaincodeProposalPayload> _parser = new pb::MessageParser<ChaincodeProposalPayload>(() => new ChaincodeProposalPayload());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ChaincodeProposalPayload> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protos.ProposalReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ChaincodeProposalPayload() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ChaincodeProposalPayload(ChaincodeProposalPayload other) : this() {
      input_ = other.input_;
      transientMap_ = other.transientMap_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ChaincodeProposalPayload Clone() {
      return new ChaincodeProposalPayload(this);
    }

    /// <summary>Field number for the "input" field.</summary>
    public const int InputFieldNumber = 1;
    private pb::ByteString input_ = pb::ByteString.Empty;
    /// <summary>
    /// Input contains the arguments for this invocation. If this invocation
    /// deploys a new chaincode, ESCC/VSCC are part of this field.
    /// This is usually a marshaled ChaincodeInvocationSpec
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Input {
      get { return input_; }
      set {
        input_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "TransientMap" field.</summary>
    public const int TransientMapFieldNumber = 2;
    private static readonly pbc::MapField<string, pb::ByteString>.Codec _map_transientMap_codec
        = new pbc::MapField<string, pb::ByteString>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForBytes(18), 18);
    private readonly pbc::MapField<string, pb::ByteString> transientMap_ = new pbc::MapField<string, pb::ByteString>();
    /// <summary>
    /// TransientMap contains data (e.g. cryptographic material) that might be used
    /// to implement some form of application-level confidentiality. The contents
    /// of this field are supposed to always be omitted from the transaction and
    /// excluded from the ledger.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, pb::ByteString> TransientMap {
      get { return transientMap_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ChaincodeProposalPayload);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ChaincodeProposalPayload other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Input != other.Input) return false;
      if (!TransientMap.Equals(other.TransientMap)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Input.Length != 0) hash ^= Input.GetHashCode();
      hash ^= TransientMap.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Input.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Input);
      }
      transientMap_.WriteTo(output, _map_transientMap_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Input.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Input);
      }
      size += transientMap_.CalculateSize(_map_transientMap_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ChaincodeProposalPayload other) {
      if (other == null) {
        return;
      }
      if (other.Input.Length != 0) {
        Input = other.Input;
      }
      transientMap_.Add(other.transientMap_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Input = input.ReadBytes();
            break;
          }
          case 18: {
            transientMap_.AddEntriesFrom(input, _map_transientMap_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// ChaincodeAction contains the actions the events generated by the execution
  /// of the chaincode.
  /// </summary>
  public sealed partial class ChaincodeAction : pb::IMessage<ChaincodeAction> {
    private static readonly pb::MessageParser<ChaincodeAction> _parser = new pb::MessageParser<ChaincodeAction>(() => new ChaincodeAction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ChaincodeAction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protos.ProposalReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ChaincodeAction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ChaincodeAction(ChaincodeAction other) : this() {
      results_ = other.results_;
      events_ = other.events_;
      Response = other.response_ != null ? other.Response.Clone() : null;
      ChaincodeId = other.chaincodeId_ != null ? other.ChaincodeId.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ChaincodeAction Clone() {
      return new ChaincodeAction(this);
    }

    /// <summary>Field number for the "results" field.</summary>
    public const int ResultsFieldNumber = 1;
    private pb::ByteString results_ = pb::ByteString.Empty;
    /// <summary>
    /// This field contains the read set and the write set produced by the
    /// chaincode executing this invocation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Results {
      get { return results_; }
      set {
        results_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "events" field.</summary>
    public const int EventsFieldNumber = 2;
    private pb::ByteString events_ = pb::ByteString.Empty;
    /// <summary>
    /// This field contains the events generated by the chaincode executing this
    /// invocation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Events {
      get { return events_; }
      set {
        events_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "response" field.</summary>
    public const int ResponseFieldNumber = 3;
    private global::Protos.Response response_;
    /// <summary>
    /// This field contains the result of executing this invocation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protos.Response Response {
      get { return response_; }
      set {
        response_ = value;
      }
    }

    /// <summary>Field number for the "chaincode_id" field.</summary>
    public const int ChaincodeIdFieldNumber = 4;
    private global::Protos.ChaincodeID chaincodeId_;
    /// <summary>
    /// This field contains the ChaincodeID of executing this invocation. Endorser
    /// will set it with the ChaincodeID called by endorser while simulating proposal.
    /// Committer will validate the version matching with latest chaincode version.
    /// Adding ChaincodeID to keep version opens up the possibility of multiple
    /// ChaincodeAction per transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protos.ChaincodeID ChaincodeId {
      get { return chaincodeId_; }
      set {
        chaincodeId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ChaincodeAction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ChaincodeAction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Results != other.Results) return false;
      if (Events != other.Events) return false;
      if (!object.Equals(Response, other.Response)) return false;
      if (!object.Equals(ChaincodeId, other.ChaincodeId)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Results.Length != 0) hash ^= Results.GetHashCode();
      if (Events.Length != 0) hash ^= Events.GetHashCode();
      if (response_ != null) hash ^= Response.GetHashCode();
      if (chaincodeId_ != null) hash ^= ChaincodeId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Results.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Results);
      }
      if (Events.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(Events);
      }
      if (response_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Response);
      }
      if (chaincodeId_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ChaincodeId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Results.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Results);
      }
      if (Events.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Events);
      }
      if (response_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Response);
      }
      if (chaincodeId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ChaincodeId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ChaincodeAction other) {
      if (other == null) {
        return;
      }
      if (other.Results.Length != 0) {
        Results = other.Results;
      }
      if (other.Events.Length != 0) {
        Events = other.Events;
      }
      if (other.response_ != null) {
        if (response_ == null) {
          response_ = new global::Protos.Response();
        }
        Response.MergeFrom(other.Response);
      }
      if (other.chaincodeId_ != null) {
        if (chaincodeId_ == null) {
          chaincodeId_ = new global::Protos.ChaincodeID();
        }
        ChaincodeId.MergeFrom(other.ChaincodeId);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Results = input.ReadBytes();
            break;
          }
          case 18: {
            Events = input.ReadBytes();
            break;
          }
          case 26: {
            if (response_ == null) {
              response_ = new global::Protos.Response();
            }
            input.ReadMessage(response_);
            break;
          }
          case 34: {
            if (chaincodeId_ == null) {
              chaincodeId_ = new global::Protos.ChaincodeID();
            }
            input.ReadMessage(chaincodeId_);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
